#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_GOOGLE_include_directive : require

#pragma shader_stage(raygen)

#include "../brdf.glsl"
#include "../common/random.glsl"
#include "../common/sampling.glsl"
#include "../debug.glsl"
#include "../scene/camera.glsl"
#include "../scene/geometry.glsl"
#include "../scene/lights.glsl"
#include "../scene/materials.glsl"
#include "../scene/skybox.glsl"
#include "../scene/transforms.glsl"
#include "ray.glsl"
#include "rt_data.glsl"

layout(set = OUTPUT_SET, binding = 0, rgba32f) uniform image2D previousColor;
layout(set = OUTPUT_SET, binding = 1, rgba32f) uniform image2D outColor;

#include "rtpc.glsl"

#include "payload.glsl"
layout(location = 0) rayPayloadEXT RayPayload payload;

#define MISS_INDEX 0xFFFFFFFF

float shadow(vec3 p, vec3 l, float tMin, float lDist)
{
    const uint mask = 0xFF;
    const uint flags = gl_RayFlagsTerminateOnFirstHitEXT;

    payload.instanceCustomIndex = MISS_INDEX;
    payload.randomSeed = pcg(pcg_state.x ^ pcg_state.y);

    traceRayEXT(as, flags, mask, 0, 0, 0, p, tMin, l, lDist, 0);

    return payload.instanceCustomIndex == MISS_INDEX ? 1. : 0.;
}

RayPayload traceClosest(Ray ray)
{
    const uint mask = 0xFF;
    const uint flags = gl_RayFlagsNoneEXT; // We want anyhit here

    // Tight scope for payload use as having it dangle seems to prevent reuse
    payload.instanceCustomIndex = MISS_INDEX;
    payload.primitiveID = MISS_INDEX;
    payload.baryCoord = vec2(0);
    payload.randomSeed = pcg(pcg_state.x ^ pcg_state.z);

    traceRayEXT(as, flags, mask, 0, 0, 0, ray.o, ray.tMin, ray.d, ray.tMax, 0);

    RayPayload ret;
    ret.instanceCustomIndex = payload.instanceCustomIndex;
    ret.primitiveID = payload.primitiveID;
    ret.baryCoord = payload.baryCoord;

    return ret;
}

// From 'A Fast and Robust Method for Avoiding Self-Intersection'
// by WÃ¤chter and Binder
// Published in Ray Tracing Gems
vec3 offsetRay(VisibleSurface surface)
{
    const float origin = 1.0 / 32.0;
    const float float_scale = 1.0 / 65536.0;
    const float int_scale = 256.0;

    vec3 p = surface.positionWS;
    vec3 n = surface.normalWS;

    ivec3 ofI = ivec3(int_scale * n.x, int_scale * n.y, int_scale * n.z);

    vec3 pI = vec3(
        intBitsToFloat(floatBitsToInt(p.x) + ((p.x < 0) ? -ofI.x : ofI.x)),
        intBitsToFloat(floatBitsToInt(p.y) + ((p.y < 0) ? -ofI.y : ofI.y)),
        intBitsToFloat(floatBitsToInt(p.z) + ((p.z < 0) ? -ofI.z : ofI.z)));

    return vec3(
        abs(p.x) < origin ? p.x + float_scale * n.x : pI.x,
        abs(p.y) < origin ? p.y + float_scale * n.y : pI.y,
        abs(p.z) < origin ? p.z + float_scale * n.z : pI.z);
}

void addBounce(inout vec3 accColor, vec3 color, uint bounce)
{
    if (bounce > 0 && flagClampIndirect())
        color = clamp(color, vec3(0), vec3(2));
    accColor += color;
}

void importanceSampleBounce(
    VisibleSurface surface, inout vec3 throughput, inout vec3 rd)
{
    // Multiple importance sample diffuse and specular only picking one
    // TODO: Better heuristic for specular weight
    bool specularOnly = surface.material.metallic > 0.999;
    float specularWeight = specularOnly ? 1. : 0.5;
    float diffuseWeight = 1. - specularWeight;

    mat3 normalBasis = orthonormalBasis(surface.normalWS);
    vec3 vInBasis = normalBasis * surface.invViewRayWS;
    float alpha = surface.material.roughness * surface.material.roughness;

    bool pickDiffuse = rnd01() < diffuseWeight;
    vec3 brdf;
    float NoL;
    float pdf;
    if (pickDiffuse)
    {
        rd = cosineSampleHemisphere(surface.normalWS, rnd2d01());
        NoL = saturate(dot(surface.normalWS, rd));

        brdf = lambertBRFD(surface.material.albedo);

        pdf = cosineHemispherePdf(NoL);
        // TODO:
        // This is from RTGII reference path tracer and seems correct but is
        // not energy conserving
        pdf *= diffuseWeight;
    }
    else
    {
        rd = sampleVisibleTrowbridgeReitz(vInBasis, alpha, rnd2d01());
        rd = transpose(normalBasis) * rd;
        NoL = saturate(dot(surface.normalWS, rd));

        // Common dot products
        vec3 h = normalize(surface.invViewRayWS + rd);
        float NoH = saturate(dot(surface.normalWS, h));
        float VoH = saturate(dot(surface.invViewRayWS, h));

        // Use standard approximation of default fresnel
        vec3 f0 = fresnelZero(surface);

        brdf = cookTorranceBRDF(
            NoL, surface.NoV, NoH, VoH, f0, surface.material.roughness);

        pdf = visibleTrowbridgeReitzPdf(vInBasis, normalBasis * rd, alpha);
        // TODO:
        // This is from RTGII reference path tracer and seems correct but is
        // not energy conserving
        pdf *= specularWeight;
    }
    throughput *= max(brdf * NoL / pdf, vec3(0));
}

VisibleSurface evaluateSurface(Ray ray, RayPayload hit)
{
    RTInstance instance = rtInstances.data[hit.instanceCustomIndex];

    Transforms trfn =
        modelInstanceTransforms.instance[instance.modelInstanceID];

    Vertex v0 = loadVertex(instance.meshID, hit.primitiveID * 3 + 0);
    Vertex v1 = loadVertex(instance.meshID, hit.primitiveID * 3 + 1);
    Vertex v2 = loadVertex(instance.meshID, hit.primitiveID * 3 + 2);

    Vertex vi = interpolate(v0, v1, v2, hit.baryCoord);
    Vertex v = transform(vi, trfn);

    VisibleSurface surface;
    surface.positionWS = v.Position;
    surface.invViewRayWS = -ray.d;
    surface.uv = v.TexCoord0;
    surface.material = sampleMaterial(instance.materialID, v.TexCoord0);

    // -2 signals no material normal, w=0 no vertex tangent
    if (surface.material.normal.x != -2 && v.Tangent.w != 0)
    {
        mat3 TBN = generateTBN(v.Normal, v.Tangent);
        surface.normalWS = normalize(TBN * surface.material.normal.xyz);
    }
    else
        surface.normalWS = v.Normal;

    surface.NoV = saturate(dot(surface.normalWS, surface.invViewRayWS));

    return surface;
}

vec3 debugColor(RayPayload hit, VisibleSurface surface)
{
    RTInstance instance = rtInstances.data[hit.instanceCustomIndex];

    DebugInputs di;
    di.meshID = instance.meshID;
    di.primitiveID = hit.primitiveID;
    di.materialID = instance.materialID;
    di.position = surface.positionWS;
    di.shadingNormal = surface.normalWS;
    di.texCoord0 = surface.uv;
    return commonDebugDraw(rtPC.drawType, di, surface.material);
}

vec3 evaluateDirectLighting(
    VisibleSurface surface, vec3 throughput, uint bounce)
{
    vec3 color = vec3(0);

    // Alpha=0 hits don't have a valid surface
    if (surface.material.alpha != 0)
    {
        { // Sun
            vec3 l = -normalize(directionalLight.direction.xyz);

            if (dot(l, surface.normalWS) > 0)
                addBounce(
                    color,
                    directionalLight.irradiance.xyz * throughput *
                        evalBRDFTimesNoL(l, surface) *
                        shadow(surface.positionWS, l, 0.1, 100),
                    bounce);
        }
    }

    return color;
}

void main()
{
    uvec2 px = gl_LaunchIDEXT.xy;

    pcg_state = uvec3(px, rtPC.frameIndex);

    vec2 jitteredUV = (px + rnd2d01()) / gl_LaunchSizeEXT.xy;

    vec3 color = vec3(0);
    vec3 throughput = vec3(1);
    uint bounce = 0;
    Ray ray = flagDepthOfField()
                  ? thinLensCameraRay(
                        jitteredUV, rnd2d01(), rtPC.apertureDiameter,
                        rtPC.focusDistance, rtPC.focalLength)
                  : pinholeCameraRay(jitteredUV);
    while (bounce <= MAX_BOUNCES)
    {
        RayPayload hit = traceClosest(ray);
        if (hit.instanceCustomIndex == MISS_INDEX)
        {
            if (flagIBL())
            {
                vec3 skyColor = textureLod(skybox, ray.d, 0).rgb;
                addBounce(color, throughput * skyColor, bounce);
            }
            break;
        }

        VisibleSurface surface = evaluateSurface(ray, hit);

        if (rtPC.drawType >= DrawType_PrimitiveID)
        {
            color = debugColor(hit, surface);
            break;
        }

        color += evaluateDirectLighting(surface, throughput, bounce);

        vec3 rd;
        importanceSampleBounce(surface, throughput, rd);

        if (bounce > rtPC.rouletteStartBounce)
        {
            // Russian roulette based on throughput from PBR 3rd edition
            if (rnd01() < max(.05, 1. - max3(throughput)))
                break;
        }

        ray.o = offsetRay(surface);
        ray.d = rd;
        ray.tMin = 0;
        ray.tMax = 1.0 / 0.0; // INF
        bounce++;
    }

    if (flagSkipHistory() || !flagAccumulate())
    {
        imageStore(outColor, ivec2(px), vec4(color, 1));
    }
    else
    {
        vec4 history = imageLoad(previousColor, ivec2(px));
        vec3 historyColor = history.rgb;
        float historyCount = history.a;

        vec3 newColor = historyColor + (color - historyColor) / historyCount;

        imageStore(outColor, ivec2(px), vec4(newColor, historyCount + 1));
    }
}
