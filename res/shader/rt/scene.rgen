#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#pragma shader_stage(raygen)

#include "../camera.glsl"
#include "ray.glsl"

layout(set = ACCELERATION_STRUCTURE_SET, binding = 0) uniform
    accelerationStructureEXT as;
layout(
    set = OUTPUT_SET, binding = 0, rgba16f) uniform writeonly image2D colorOut;

#include "rtpc.glsl"

#include "payload.glsl"
layout(location = 0) rayPayloadEXT RayPayload payload;

// From Supplement to Hash Functions for GPU Rendering
// By Jarzynski & Olano
// https://jcgt.org/published/0009/03/02/supplementary.pdf
uint pcg(uint v)
{
    uint state = v * 747796405 + 2891336453;
    uint word = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    return (word >> 22) ^ word;
}

vec3 uintToColor(uint x)
{
    // Hashing should, on average, favor pastellish colors that are easy on the
    // eyes. Numerically and spatially adjacent indices should also have a
    // decent probability of getting distinct colors.
    uint xr = pcg(x);
    uint r = (xr >> 20) & 0x3FF;
    uint g = (xr >> 10) & 0x3FF;
    uint b = xr & 0x3FF;
    return vec3(r, g, b) / 0x3FF;
}

struct Instance
{
    uint meshID;
    uint materialID;
};

void unpackInstance(in uint id, out Instance instance)
{
    instance.meshID = (id >> 9) & 0x7FFF;
    instance.materialID = id & 0x1FF;
}

void main()
{
    uvec2 px = gl_LaunchIDEXT.xy;
    vec2 uv = (px + 0.5) / gl_LaunchSizeEXT.xy;

    Ray ray = pinholeCameraRay(uv);

    uint mask = 0xFF;

    const uint missIndex = 0xFFFFFFFF;
    payload.instanceCustomIndex = missIndex;
    payload.primitiveID = missIndex;
    traceRayEXT(
        as, gl_RayFlagsOpaqueEXT, mask, 0, 0, 0, ray.o, ray.tMin, ray.d,
        ray.tMax, 0);

    Instance instance;
    unpackInstance(payload.instanceCustomIndex, instance);

    vec3 color = vec3(0);
    if (payload.instanceCustomIndex != missIndex)
    {
        if (rtPC.drawType == DrawType_PrimitiveID)
            color = uintToColor(payload.primitiveID);
        else if (rtPC.drawType == DrawType_MeshID)
            color = uintToColor(instance.meshID);
        else if (rtPC.drawType == DrawType_MaterialID)
            color = uintToColor(instance.materialID);
        else
            color = vec3(1, 0, 1);
    }

    imageStore(colorOut, ivec2(px), vec4(color, 1));
}
