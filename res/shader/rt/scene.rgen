#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_GOOGLE_include_directive : require

#pragma shader_stage(raygen)

#include "../camera.glsl"
#include "../debug.glsl"
#include "../geometry.glsl"
#include "../materials.glsl"
#include "../random.glsl"
#include "../transforms.glsl"
#include "ray.glsl"

layout(set = RAY_TRACING_SET, binding = 0) uniform accelerationStructureEXT as;
struct RTInstance
{
    uint modelInstanceID;
    uint meshID;
    uint materialID;
};
layout(std430, set = RAY_TRACING_SET, binding = 1) readonly buffer RTInstances
{
    RTInstance data[];
}
rtInstances;
layout(
    set = OUTPUT_SET, binding = 0, rgba16f) uniform writeonly image2D colorOut;

#include "rtpc.glsl"

#include "payload.glsl"
layout(location = 0) rayPayloadEXT RayPayload payload;

void main()
{
    uvec2 px = gl_LaunchIDEXT.xy;
    vec2 uv = (px + 0.5) / gl_LaunchSizeEXT.xy;

    Ray ray = pinholeCameraRay(uv);

    uint mask = 0xFF;

    const uint missIndex = 0xFFFFFFFF;
    payload.instanceCustomIndex = missIndex;
    payload.primitiveID = missIndex;
    traceRayEXT(
        as, gl_RayFlagsOpaqueEXT, mask, 0, 0, 0, ray.o, ray.tMin, ray.d,
        ray.tMax, 0);

    vec3 color = vec3(0);
    if (payload.instanceCustomIndex != missIndex)
    {
        RTInstance instance = rtInstances.data[payload.instanceCustomIndex];

        Transforms trfn =
            modelInstanceTransforms.instance[instance.modelInstanceID];

        Vertex v0 = loadVertex(instance.meshID, payload.primitiveID * 3 + 0);
        Vertex v1 = loadVertex(instance.meshID, payload.primitiveID * 3 + 1);
        Vertex v2 = loadVertex(instance.meshID, payload.primitiveID * 3 + 2);

        Vertex vi = interpolate(v0, v1, v2, payload.baryCoord);
        Vertex v = transform(vi, trfn);

        Material m = sampleMaterial(instance.materialID, v.TexCoord0);

        vec3 normal;
        // -2 signals no material normal, w=0 no vertex tangent
        if (m.normal.x != -2 && v.Tangent.w != 0)
        {
            mat3 TBN = generateTBN(v.Normal, v.Tangent);
            normal = normalize(TBN * m.normal.xyz);
        }
        else
            normal = v.Normal;

        if (rtPC.drawType >= DrawType_PrimitiveID)
        {
            DebugInputs di;
            di.meshID = instance.meshID;
            di.primitiveID = payload.primitiveID;
            di.materialID = instance.materialID;
            di.position = v.Position;
            di.shadingNormal = normal;
            di.texCoord0 = v.TexCoord0;
            color = commonDebugDraw(rtPC.drawType, di, m);
        }
        else
            color = vec3(1, 0, 1);
    }

    imageStore(colorOut, ivec2(px), vec4(color, 1));
}
