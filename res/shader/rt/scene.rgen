#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#pragma shader_stage(raygen)

#include "../camera.glsl"
#include "../debug.glsl"
#include "../random.glsl"
#include "ray.glsl"

layout(set = ACCELERATION_STRUCTURE_SET, binding = 0) uniform
    accelerationStructureEXT as;
layout(
    set = OUTPUT_SET, binding = 0, rgba16f) uniform writeonly image2D colorOut;

#include "rtpc.glsl"

#include "payload.glsl"
layout(location = 0) rayPayloadEXT RayPayload payload;

struct Instance
{
    uint meshID;
    uint materialID;
};

void unpackInstance(in uint id, out Instance instance)
{
    instance.meshID = (id >> 9) & 0x7FFF;
    instance.materialID = id & 0x1FF;
}

void main()
{
    uvec2 px = gl_LaunchIDEXT.xy;
    vec2 uv = (px + 0.5) / gl_LaunchSizeEXT.xy;

    Ray ray = pinholeCameraRay(uv);

    uint mask = 0xFF;

    const uint missIndex = 0xFFFFFFFF;
    payload.instanceCustomIndex = missIndex;
    payload.primitiveID = missIndex;
    traceRayEXT(
        as, gl_RayFlagsOpaqueEXT, mask, 0, 0, 0, ray.o, ray.tMin, ray.d,
        ray.tMax, 0);

    Instance instance;
    unpackInstance(payload.instanceCustomIndex, instance);

    vec3 color = vec3(0);
    if (payload.instanceCustomIndex != missIndex)
    {
        if (rtPC.drawType >= CommonDebugDrawTypeOffset)
        {
            DebugInputs di;
            di.meshID = instance.meshID;
            di.primitiveID = payload.primitiveID;
            di.materialID = instance.materialID;
            di.normal = normalize(vec3(1, 1, 1));
            Material m;
            uint drawType = rtPC.drawType - CommonDebugDrawTypeOffset;
            color = commonDebugDraw(drawType, di, m);
        }
        else
            color = vec3(1, 0, 1);
    }

    imageStore(colorOut, ivec2(px), vec4(color, 1));
}
