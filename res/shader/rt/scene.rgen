#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_GOOGLE_include_directive : require

#pragma shader_stage(raygen)

#include "../brdf.glsl"
#include "../camera.glsl"
#include "../debug.glsl"
#include "../geometry.glsl"
#include "../lights.glsl"
#include "../materials.glsl"
#include "../random.glsl"
#include "../sampling.glsl"
#include "../transforms.glsl"
#include "ray.glsl"
#include "rt_data.glsl"

layout(set = OUTPUT_SET, binding = 0, rgba16f) uniform image2D colorInOut;
layout(set = SKYBOX_SET, binding = 0) uniform samplerCube skybox;

#include "rtpc.glsl"

#include "payload.glsl"
layout(location = 0) rayPayloadEXT RayPayload payload;

#define MISS_INDEX 0xFFFFFFFF

float shadow(vec3 p, vec3 l, float tMin, float lDist)
{
    const uint mask = 0xFF;
    const uint flags = gl_RayFlagsTerminateOnFirstHitEXT;

    payload.instanceCustomIndex = MISS_INDEX;
    payload.randomSeed = pcg(pcg_state.x ^ pcg_state.y);

    traceRayEXT(as, flags, mask, 0, 0, 0, p, tMin, l, lDist, 0);

    return float(payload.instanceCustomIndex == MISS_INDEX);
}

RayPayload traceClosest(Ray ray)
{
    const uint mask = 0xFF;
    const uint flags = gl_RayFlagsNoneEXT; // We want anyhit here

    // Tight scope for payload use as having it dangle seems to prevent reuse
    payload.instanceCustomIndex = MISS_INDEX;
    payload.primitiveID = MISS_INDEX;
    payload.baryCoord = vec2(0);
    payload.randomSeed = pcg(pcg_state.x ^ pcg_state.z);

    traceRayEXT(as, flags, mask, 0, 0, 0, ray.o, ray.tMin, ray.d, ray.tMax, 0);

    RayPayload ret;
    ret.instanceCustomIndex = payload.instanceCustomIndex;
    ret.primitiveID = payload.primitiveID;
    ret.baryCoord = payload.baryCoord;

    return ret;
}

// From 'A Fast and Robust Method for Avoiding Self-Intersection'
// by WÃ¤chter and Binder
// Published in Ray Tracing Gems
vec3 offsetRay(VisibleSurface surface)
{
    const float origin = 1.0 / 32.0;
    const float float_scale = 1.0 / 65536.0;
    const float int_scale = 256.0;

    vec3 p = surface.positionWS;
    vec3 n = surface.normalWS;

    ivec3 ofI = ivec3(int_scale * n.x, int_scale * n.y, int_scale * n.z);

    vec3 pI = vec3(
        intBitsToFloat(floatBitsToInt(p.x) + ((p.x < 0) ? -ofI.x : ofI.x)),
        intBitsToFloat(floatBitsToInt(p.y) + ((p.y < 0) ? -ofI.y : ofI.y)),
        intBitsToFloat(floatBitsToInt(p.z) + ((p.z < 0) ? -ofI.z : ofI.z)));

    return vec3(
        abs(p.x) < origin ? p.x + float_scale * n.x : pI.x,
        abs(p.y) < origin ? p.y + float_scale * n.y : pI.y,
        abs(p.z) < origin ? p.z + float_scale * n.z : pI.z);
}

#define MAX_BOUNCES 3

void main()
{

    uvec2 px = gl_LaunchIDEXT.xy;

    pcg_state = uvec3(px, rtPC.frameIndex);

    vec2 jitteredUV = (px + rnd2d01()) / gl_LaunchSizeEXT.xy;

    vec3 color = vec3(0);
    vec3 throughput = vec3(1);
    uint bounce = 1;
    Ray ray = pinholeCameraRay(jitteredUV);
    while (bounce <= MAX_BOUNCES)
    {
        RayPayload hit = traceClosest(ray);
        if (hit.instanceCustomIndex == MISS_INDEX)
        {
            if (flagIBL())
            {
                vec3 skyColor = sRGBtoLinear(textureLod(skybox, ray.d, 0).rgb);
                color += throughput * skyColor;
            }
            break;
        }

        RTInstance instance = rtInstances.data[hit.instanceCustomIndex];

        Transforms trfn =
            modelInstanceTransforms.instance[instance.modelInstanceID];

        Vertex v0 = loadVertex(instance.meshID, hit.primitiveID * 3 + 0);
        Vertex v1 = loadVertex(instance.meshID, hit.primitiveID * 3 + 1);
        Vertex v2 = loadVertex(instance.meshID, hit.primitiveID * 3 + 2);

        Vertex vi = interpolate(v0, v1, v2, hit.baryCoord);
        Vertex v = transform(vi, trfn);

        VisibleSurface surface;
        surface.positionWS = v.Position;
        surface.invViewRayWS = -ray.d;
        surface.material = sampleMaterial(instance.materialID, v.TexCoord0);

        // -2 signals no material normal, w=0 no vertex tangent
        if (surface.material.normal.x != -2 && v.Tangent.w != 0)
        {
            mat3 TBN = generateTBN(v.Normal, v.Tangent);
            surface.normalWS = normalize(TBN * surface.material.normal.xyz);
        }
        else
            surface.normalWS = v.Normal;

        surface.NoV = saturate(dot(surface.normalWS, surface.invViewRayWS));

        if (rtPC.drawType >= DrawType_PrimitiveID)
        {
            DebugInputs di;
            di.meshID = instance.meshID;
            di.primitiveID = hit.primitiveID;
            di.materialID = instance.materialID;
            di.position = surface.positionWS;
            di.shadingNormal = surface.normalWS;
            di.texCoord0 = v.TexCoord0;
            color = commonDebugDraw(rtPC.drawType, di, surface.material);

            break;
        }

        // Alpha hits don't have a valid surface
        if (surface.material.alpha != 0)
        {
            { // Sun
                vec3 l = -normalize(directionalLight.direction.xyz);

                color += directionalLight.irradiance.xyz * throughput *
                         evalBRDF(l, surface) *
                         shadow(surface.positionWS, l, 0.1, 100);
            }
        }

        // TODO: Early out if throughput is small
        // TODO: Russian roulette

        vec3 rd;
        float pdf;
        cosineSampleHemisphere(surface.normalWS, rnd2d01(), rd, pdf);

        throughput *= evalBRDF(rd, surface) / pdf;

        ray.o = offsetRay(surface);
        ray.d = rd;
        ray.tMin = 0;
        ray.tMax = 1.0 / 0.0; // INF
        bounce++;
    }

    if (flagColorDirty() || !flagAccumulate())
    {
        imageStore(colorInOut, ivec2(px), vec4(color, 1));
    }
    else
    {
        vec4 history = imageLoad(colorInOut, ivec2(px));
        vec3 historyColor = history.rgb;
        float historyCount = history.a;

        vec3 newColor = historyColor + (color - historyColor) / historyCount;

        imageStore(colorInOut, ivec2(px), vec4(newColor, historyCount + 1));
    }
}
