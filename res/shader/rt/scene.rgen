#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_GOOGLE_include_directive : require

#pragma shader_stage(raygen)

#include "../camera.glsl"
#include "../debug.glsl"
#include "../geometry.glsl"
#include "../lights.glsl"
#include "../materials.glsl"
#include "../random.glsl"
#include "../transforms.glsl"
#include "ray.glsl"

layout(set = RAY_TRACING_SET, binding = 0) uniform accelerationStructureEXT as;
struct RTInstance
{
    uint modelInstanceID;
    uint meshID;
    uint materialID;
};
layout(std430, set = RAY_TRACING_SET, binding = 1) readonly buffer RTInstances
{
    RTInstance data[];
}
rtInstances;
layout(
    set = OUTPUT_SET, binding = 0, rgba16f) uniform writeonly image2D colorOut;

#include "rtpc.glsl"

#include "payload.glsl"
layout(location = 0) rayPayloadEXT RayPayload payload;

#define MISS_INDEX 0xFFFFFFFF

float shadow(vec3 p, vec3 l, float tMin, float lDist)
{
    uint mask = 0xFF;

    // TODO: simpler shaders for shadow rays
    payload.instanceCustomIndex = MISS_INDEX;
    traceRayEXT(as, gl_RayFlagsOpaqueEXT, mask, 0, 0, 0, p, tMin, l, lDist, 0);

    return float(payload.instanceCustomIndex == MISS_INDEX);
}

RayPayload traceClosest(Ray ray)
{
    uint mask = 0xFF;

    // Tight scope for payload use as having it dangle seems to prevent reuse
    payload.instanceCustomIndex = MISS_INDEX;
    payload.primitiveID = MISS_INDEX;
    payload.baryCoord = vec2(0);

    traceRayEXT(
        as, gl_RayFlagsOpaqueEXT, mask, 0, 0, 0, ray.o, ray.tMin, ray.d,
        ray.tMax, 0);

    RayPayload ret;
    ret.instanceCustomIndex = payload.instanceCustomIndex;
    ret.primitiveID = payload.primitiveID;
    ret.baryCoord = payload.baryCoord;

    return ret;
}

void main()
{
    uvec2 px = gl_LaunchIDEXT.xy;
    vec2 uv = (px + 0.5) / gl_LaunchSizeEXT.xy;

    Ray ray = pinholeCameraRay(uv);
    RayPayload hit = traceClosest(ray);

    vec3 color = vec3(0);
    if (hit.instanceCustomIndex != MISS_INDEX)
    {
        RTInstance instance = rtInstances.data[hit.instanceCustomIndex];

        Transforms trfn =
            modelInstanceTransforms.instance[instance.modelInstanceID];

        Vertex v0 = loadVertex(instance.meshID, hit.primitiveID * 3 + 0);
        Vertex v1 = loadVertex(instance.meshID, hit.primitiveID * 3 + 1);
        Vertex v2 = loadVertex(instance.meshID, hit.primitiveID * 3 + 2);

        Vertex vi = interpolate(v0, v1, v2, hit.baryCoord);
        Vertex v = transform(vi, trfn);

        Material m = sampleMaterial(instance.materialID, v.TexCoord0);

        vec3 normal;
        // -2 signals no material normal, w=0 no vertex tangent
        if (m.normal.x != -2 && v.Tangent.w != 0)
        {
            mat3 TBN = generateTBN(v.Normal, v.Tangent);
            normal = normalize(TBN * m.normal.xyz);
        }
        else
            normal = v.Normal;

        // Alpha hits don't have a valid surface
        if (m.alpha != 0)
        {
            { // Sun
                vec3 l = -normalize(directionalLight.direction.xyz);

                color += directionalLight.irradiance.xyz *
                         evalBRDF(normal, -ray.d, l, m) *
                         shadow(v.Position, l, 0.1, 100);
            }
        }

        if (rtPC.drawType >= DrawType_PrimitiveID)
        {
            DebugInputs di;
            di.meshID = instance.meshID;
            di.primitiveID = hit.primitiveID;
            di.materialID = instance.materialID;
            di.position = v.Position;
            di.shadingNormal = normal;
            di.texCoord0 = v.TexCoord0;
            color = commonDebugDraw(rtPC.drawType, di, m);
        }
    }

    imageStore(colorOut, ivec2(px), vec4(color, 1));
}
