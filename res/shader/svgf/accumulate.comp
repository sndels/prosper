#pragma shader_stage(compute)

#extension GL_EXT_shader_image_load_formatted : require

// Based on
// Spatiotemporal Variance-Guided Filtering: Real-Time Reconstruction for
// Path-Traced Global Illumination
// by Schied et al.

#include "../common/math.glsl"
#include "../scene/camera.glsl"
#include "../scene/material.glsl"

layout(constant_id = 0) const bool IGNORE_HISTORY = false;

layout(set = STORAGE_SET, binding = 0) uniform texture2D inColor;
layout(set = STORAGE_SET, binding = 1) uniform texture2D inAlbedoRoughness;
layout(set = STORAGE_SET, binding = 2) uniform texture2D inNormalMetallic;
layout(set = STORAGE_SET, binding = 3) uniform texture2D inVelocity;
layout(set = STORAGE_SET, binding = 4) uniform texture2D inNonLinearDepth;
layout(set = STORAGE_SET, binding = 5) uniform texture2D
    inPreviousAlbedoRoughness;
layout(set = STORAGE_SET, binding = 6) uniform texture2D
    inPreviousNormalMetallic;
layout(set = STORAGE_SET, binding = 7) uniform texture2D
    inPreviousNonLinearDepth;
layout(set = STORAGE_SET, binding = 8) uniform texture2D inIntegratedColor;
layout(set = STORAGE_SET, binding = 9) uniform texture2D inIntegratedMoments;
layout(set = STORAGE_SET, binding = 10) uniform writeonly image2D outColor;
layout(set = STORAGE_SET, binding = 11) uniform writeonly image2D outMoments;
layout(set = STORAGE_SET, binding = 12) uniform sampler nearestSampler;

#define sampleNearest(tex, uv) texture(sampler2D(tex, nearestSampler), uv)

// TODO:
// Pre-read all taps for a wave into shared mem

struct Surface
{
    vec3 positionWS;
    vec3 normalWS;
};

void reprojectTap(
    vec2 uv, Surface referenceSurface, inout vec3 color, inout float weight)
{
    // TODO:
    // Reproject and validate
    color = vec3(0);

    vec3 new_albedo = vec3(0);
    vec3 new_color = vec3(0);
    // Recover raw illumination to avoid "denoising" texture detail
    new_color *= PI / new_albedo;

    weight = 0.;
}

layout(local_size_x = GROUP_X, local_size_y = GROUP_Y) in;
void main()
{
    ivec2 res = imageSize(outColor);
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(px, res)))
        return;
    vec2 uv = pxToUv(px, res);

    vec3 new_color = sampleNearest(inColor, uv).xyz;
    vec3 new_albedo = sampleNearest(inAlbedoRoughness, uv).xyz;
    // Recover raw illumination to avoid "denoising" texture detail
    new_color *= PI / new_albedo;

    if (IGNORE_HISTORY)
    {
        vec2 moments = vec2(0.); // TODO

        imageStore(outColor, px, vec4(new_color, 1));
        imageStore(outMoments, px, vec4(moments, 0, 0));
        return;
    }

    Surface referenceSurface;
    referenceSurface.positionWS =
        worldPos(uv, sampleNearest(inNonLinearDepth, uv).x);
    referenceSurface.normalWS =
        signedOctDecode(sampleNearest(inNormalMetallic, uv).xyz);

    vec2 reprojectedUv = uv - velocity * vec2(.5, -.5);
    vec2 reprojectedPx = reprojectedUv * vec2(res);
    // TODO:
    // Bilinear weights from reprojected px
    // Round reprojected px
    float weights[4];
    reprojectedUv = (reprojectedPx - .5) / vec2(res);

    vec3 colors[4];
    ivec2 offsets[4]; // UV offsets
    // First try sampling 2x2
    bool foundValidTap = false;
    for (int i = 0; i < 4; ++i)
    {
        weights[i] = 0.25;
        reprojectTap(
            reprojectedUv + offsets[i], referenceSurface, colors[i],
            weights[i]);
        if (weights[i] > 0.)
            foundValidTap = true;
        else
        {
            for (int j = 0; j < i; ++j)
            {
                if (weights[j] > 0.)
                {
                    weights[j] += 0.25 / 4;
                }
            }
            for (int j = i; j < 4; ++j)
                weights[j] += 0.25 / 4;
        }
    }

    if (!foundValidTap)
    {
        // TODO:
        // Sample rest of 3x3
        // Average of valid taps?
    }

    vec3 color = vec3(0);
    vec2 moments = vec2(0);
    if (foundValidTap)
    {
        // TODO:
        // Combine all valid taps into final color
        // Calculate moments
    }
    else
    {
        color = new_color;
        // TODO:
        // Calculate moments
    }

    imageStore(outColor, px, vec4(color, 1));
    imageStore(outMoments, px, vec4(moments, 0, 0));
}
