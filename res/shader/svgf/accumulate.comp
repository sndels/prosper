#pragma shader_stage(compute)

#extension GL_EXT_shader_image_load_formatted : require

// Based on
// Spatiotemporal Variance-Guided Filtering: Real-Time Reconstruction for
// Path-Traced Global Illumination
// by Schied et al.

#include "../common/math.glsl"
#include "../scene/camera.glsl"
#include "../scene/material.glsl"

layout(constant_id = 0) const bool IGNORE_HISTORY = false;

layout(set = STORAGE_SET, binding = 0) uniform texture2D inColor;
layout(set = STORAGE_SET, binding = 1) uniform texture2D inAlbedoRoughness;
layout(set = STORAGE_SET, binding = 2) uniform texture2D inNormalMetallic;
layout(set = STORAGE_SET, binding = 3) uniform texture2D inVelocity;
layout(set = STORAGE_SET, binding = 4) uniform texture2D inNonLinearDepth;
layout(set = STORAGE_SET, binding = 5) uniform texture2D
    inPreviousAlbedoRoughness;
layout(set = STORAGE_SET, binding = 6) uniform texture2D
    inPreviousNormalMetallic;
layout(set = STORAGE_SET, binding = 7) uniform texture2D
    inPreviousNonLinearDepth;
layout(set = STORAGE_SET, binding = 8) uniform texture2D inIntegratedColor;
layout(set = STORAGE_SET, binding = 9) uniform texture2D inIntegratedMoments;
layout(set = STORAGE_SET, binding = 10) uniform writeonly image2D outColor;
layout(set = STORAGE_SET, binding = 11) uniform writeonly image2D outMoments;
layout(set = STORAGE_SET, binding = 12) uniform sampler nearestSampler;

#define sampleNearest(tex, uv) texture(sampler2D(tex, nearestSampler), uv)

// TODO:
// Pre-read all taps for a wave into shared mem?

struct Surface
{
    vec3 positionWS;
    vec3 normalWS;
};

bool readTap(vec2 uv, Surface referenceSurface, inout vec3 color)
{
    if (any(notEqual(uv, saturate(uv))))
        return false;

    // TODO:
    // Reproject and validate
    color = vec3(0);

    vec3 normalWS =
        signedOctDecode(sampleNearest(inPreviousNormalMetallic, uv).xyz);
    vec3 positionWS =
        previousWorldPos(uv, sampleNearest(inPreviousNonLinearDepth, uv).x);

    const float positionEpsilonSq = .01;
    vec3 fromPreviousPosition = positionWS - referenceSurface.positionWS;
    if (dot(fromPreviousPosition, fromPreviousPosition) > positionEpsilonSq)
        return false;

    const float normalEpsilon = .1;
    if (1. - dot(normalWS, referenceSurface.normalWS) > normalEpsilon)
        return false;

    color = sampleNearest(inIntegratedColor, uv).xyz;
    return true;
}

layout(local_size_x = GROUP_X, local_size_y = GROUP_Y) in;
void main()
{
    ivec2 resi = imageSize(outColor);
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(px, resi)))
        return;
    vec2 res = vec2(resi);
    vec2 uv = pxToUv(px, res);

    vec3 new_color = sampleNearest(inColor, uv).xyz;
    vec3 new_albedo = sampleNearest(inAlbedoRoughness, uv).xyz;
    // Recover raw illumination to avoid "denoising" texture detail
    new_color *= PI / new_albedo;

    if (IGNORE_HISTORY)
    {
        vec2 moments = vec2(0.); // TODO

        imageStore(outColor, px, vec4(new_color, 1));
        imageStore(outMoments, px, vec4(moments, 0, 0));
        return;
    }

    Surface referenceSurface;
    referenceSurface.positionWS =
        worldPos(uv, sampleNearest(inNonLinearDepth, uv).x);
    referenceSurface.normalWS =
        signedOctDecode(sampleNearest(inNormalMetallic, uv).xyz);

    vec2 velocity = sampleNearest(inVelocity, uv).xy;
    vec2 reprojectedUv = uv - velocity * vec2(.5, -.5);
    vec2 reprojectedPx = reprojectedUv * res;
    vec2 reprojectedClosestPx = round(reprojectedPx);
    vec2 bt = fract(reprojectedPx - .5);
    reprojectedUv = (reprojectedClosestPx - .5) / res;

    vec3 colors[4];
    vec2 offsets[4] = {
        vec2(0, 0) / res,
        vec2(1, 0) / res,
        vec2(0, 1) / res,
        vec2(1, 1) / res,
    };
    // mix(
    //   mix(c00, c01, tx),
    //   mix(c10, c11, tx),
    //   ty
    // )
    // expanded using mix(a, b, t) = a + t * (b - a)
    float weights[4] = {
        1 - bt.x - bt.y + bt.x * bt.y,
        bt.x - bt.x * bt.y,
        bt.y - bt.x * bt.y,
        bt.x * bt.y,
    };
    // First try sampling 2x2
    int validTaps = 4;
    for (int i = 0; i < 4; ++i)
    {
        if (readTap(reprojectedUv + offsets[i], referenceSurface, colors[i]))
            continue;

        validTaps -= 1;
        if (validTaps == 0)
            continue;

        // Distribute the weight of the invalid tap to the valid ones
        float w = weights[i] / validTaps;
        for (int j = 0; j < i; ++j)
        {
            if (weights[j] > 0.)
                weights[j] += w;
        }
        for (int j = i; j < 4; ++j)
            weights[j] += w;
        weights[i] = 0.;
    }

    vec3 history_color = vec3(0);
    vec2 history_moments = vec2(0);
    if (validTaps > 0)
    {
        for (int i = 0; i < 4; ++i)
            history_color += colors[i] * weights[i];
        // TODO:
        // Calculate moments
    }
    else
    {
        // TODO:
        // Sample rest of 3x3
        // Average of valid taps?
        history_color = new_color;
    }
    // history_color = new_color;

    const float alpha = .2;
    vec3 color = alpha * new_color + (1 - alpha) * history_color;
    vec2 moments = history_moments; // TODO

    imageStore(outColor, px, vec4(color, 1));
    imageStore(outMoments, px, vec4(moments, 0, 0));
}
