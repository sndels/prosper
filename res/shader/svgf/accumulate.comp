#pragma shader_stage(compute)

#extension GL_EXT_shader_image_load_formatted : require

// Based on
// Spatiotemporal Variance-Guided Filtering: Real-Time Reconstruction for
// Path-Traced Global Illumination
// by Schied et al.

#include "../common/math.glsl"
#include "../scene/camera.glsl"

layout(constant_id = 0) const bool IGNORE_HISTORY = false;

layout(set = STORAGE_SET, binding = 0) uniform texture2D inColor;
layout(set = STORAGE_SET, binding = 1) uniform texture2D inAlbedoRoughness;
layout(set = STORAGE_SET, binding = 2) uniform texture2D inNormalMetallic;
layout(set = STORAGE_SET, binding = 3) uniform texture2D inVelocity;
layout(set = STORAGE_SET, binding = 4) uniform texture2D inNonLinearDepth;
layout(set = STORAGE_SET, binding = 5) uniform texture2D
    inPreviousAlbedoRoughness;
layout(set = STORAGE_SET, binding = 6) uniform texture2D
    inPreviousNormalMetallic;
layout(set = STORAGE_SET, binding = 7) uniform texture2D
    inPreviousNonLinearDepth;
layout(set = STORAGE_SET, binding = 8) uniform texture2D inIntegratedColor;
layout(set = STORAGE_SET, binding = 9) uniform texture2D inIntegratedMoments;
layout(set = STORAGE_SET, binding = 10) uniform writeonly image2D outColor;
layout(set = STORAGE_SET, binding = 11) uniform writeonly image2D outMoments;
layout(set = STORAGE_SET, binding = 12) uniform sampler nearestSampler;

#define nearestSample(tex, uv) texture(sampler2D(tex, nearestSampler), uv)

// TODO:
// Pre-read all taps for a wave into shared mem

void reprojectTap(vec2 uv, inout vec3 color, inout float weight)
{
    // TODO:
    // Reproject and validate
    color = vec3(0);

    vec3 new_albedo = vec3(0);
    vec3 new_color = vec3(0);
    // Recover raw illumination to avoid "denoising" texture detail
    new_color *= PI / new_albedo;

    weight = 0.;
}

layout(local_size_x = GROUP_X, local_size_y = GROUP_Y) in;
void main()
{
    ivec2 res = imageSize(outColor);
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(px, res)))
        return;

    if (IGNORE_HISTORY)
    {
        vec2 uv = pxToUv(px, res);
        vec3 color = nearestSample(inColor, uv).xyz;
        vec2 moments = vec2(0.);

        imageStore(outColor, px, vec4(color, 1));
        imageStore(outMoments, px, vec4(moments, 0, 0));
        return;
    }

    vec3 colors[9];
    ivec2 offsets[9];
    float weights[9];

    // First sample 2x2
    bool foundValidTap = false;
    for (int i = 0; i < 4; ++i)
    {
        weights[i] = 0.25;
        vec2 uv = pxToUv(px + offsets[i], res);
        reprojectTap(uv, colors[i], weights[i]);
        if (weights[i] > 0.)
            foundValidTap = true;
        else
        {
            for (int j = 0; j < i; ++j)
            {
                if (weights[j] > 0.)
                {
                    weights[j] += 0.25 / 4;
                }
            }
            for (int j = i; j < 4; ++j)
                weights[j] += 0.25 / 4;
        }
    }

    if (!foundValidTap)
    {
        // TODO:
        // Sample rest of 3x3
    }

    vec3 color = vec3(0);
    vec2 moments = vec2(0);
    if (foundValidTap)
    {
        // TODO:
        // Combine all valid taps into final color
        // Calculate moments
    }
    else
    {
        vec2 uv = pxToUv(px, res);
        color = nearestSample(inColor, uv).xyz;
        vec3 albedo = nearestSample(inAlbedoRoughness, uv).xyz;
        // Recover raw illumination to avoid "denoising" texture detail
        color *= PI / albedo;
        // TODO:
        // Calculate moments
    }

    imageStore(outColor, px, vec4(color, 1));
    imageStore(outMoments, px, vec4(moments, 0, 0));
}
