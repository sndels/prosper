#pragma shader_stage(compute)

#extension GL_EXT_shader_image_load_formatted : require

#include "../common/math.glsl"
#include "../shared/shader_structs/push_constants/bloom/fft.h"

layout(set = 0, binding = 0) uniform readonly image2D inData;
layout(set = 0, binding = 1) uniform writeonly image2D outData;

layout(push_constant) uniform PushConstants { FftPC PC; };

bool flagTranspose() { return bitfieldExtract(PC.flags, 0, 1) == 1; }
bool flagInverse() { return bitfieldExtract(PC.flags, 1, 1) == 1; }

vec4 loadInput(ivec2 p, bool doInverse)
{
    // TODO:
    // This check should only be needed for the first pass that samples from the
    // potentially smaller input texture
    if (any(greaterThanEqual(p, PC.inputResolution)))
        return vec4(0);

    vec4 ret = imageLoad(inData, p);
    if (doInverse)
        ret = ret.yxwz;
    return ret;
}

void storeOutput(ivec2 p, vec4 c, bool doInverse)
{
    if (doInverse)
        c = c.yxwz;
    imageStore(outData, p, c);
}

// Based on
// High Performance Discrete Fourier Transforms on Graphics Processors
// By Govindaraju et al.

uint expand(uint idxL, uint N1, uint N2)
{
    return (idxL / N1) * N1 * N2 + (idxL % N1);
}

vec4 mulI(vec4 c) { return vec4(-c.y, c.x, -c.w, c.z); }

vec4 mulComplex(vec4 a, vec4 b)
{
    return vec4(
        a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x, a.z * b.z - a.w * b.w,
        a.z * b.w + a.w * b.z);
}

void decimateRadix2(inout vec4 v[2])
{
    vec4 v0 = v[0];
    vec4 v1 = v[1];
    v[0] = v0 + v1;
    v[1] = v0 - v1;
}

void decimateRadix4(inout vec4 v[4])
{
    vec4 v0 = v[0];
    vec4 v1 = v[1];
    vec4 v2 = v[2];
    vec4 v3 = v[3];
    v[0] = v0 + v1 + v2 + v3;
    v[1] = v0 - mulI(v1) - v2 + mulI(v3);
    v[2] = v0 - v1 + v2 - v3;
    v[3] = v0 + mulI(v1) - v2 - mulI(v3);
}

void fftIterationRadix2(
    uint j, uint row, uint N, uint Ns, bool doTranspose, bool doInverse)
{
    const uint R = 2;
    vec4 v[R];

    uint idxS = j;
    float angle = -2. * PI * float(j % Ns) / float(Ns * R);
    for (uint r = 0; r < R; ++r)
    {
        ivec2 p = doTranspose ? ivec2(row, idxS + r * N / R)
                              : ivec2(idxS + r * N / R, row);
        // TODO:
        // Use some kind of LUT for the sines and cosines here, like ryg
        // suggests?
        vec4 c = loadInput(p, doInverse);
        vec2 twiddle = vec2(cos(r * angle), sin(r * angle));
        v[r] = mulComplex(c, twiddle.xyxy);
    }

    decimateRadix2(v);

    uint idxD = expand(j, Ns, R);
    for (uint r = 0; r < R; ++r)
    {
        ivec2 p =
            doTranspose ? ivec2(row, idxD + r * Ns) : ivec2(idxD + r * Ns, row);
        storeOutput(p, v[r], doInverse);
    }
}

void fftIterationRadix4(
    uint j, uint row, uint N, uint Ns, bool doTranspose, bool doInverse)
{
    const uint R = 4;
    vec4 v[R];

    uint idxS = j;
    float angle = -2. * PI * float(j % Ns) / float(Ns * R);
    for (uint r = 0; r < R; ++r)
    {
        float col = idxS + r * N / R;
        ivec2 p = doTranspose ? ivec2(row, col) : ivec2(col, row);
        // TODO:
        // Use some kind of LUT for the sines and cosines here, like ryg
        // suggests?
        vec4 c = loadInput(p, doInverse);
        vec2 twiddle = vec2(cos(r * angle), sin(r * angle));
        v[r] = mulComplex(c, twiddle.xyxy);
    }

    decimateRadix4(v);

    uint idxD = expand(j, Ns, R);
    for (uint r = 0; r < R; ++r)
    {
        float col = idxD + r * Ns;
        ivec2 p = doTranspose ? ivec2(row, col) : ivec2(col, row);
        storeOutput(p, v[r], doInverse);
    }
}

layout(local_size_x = GROUP_X) in;
void main()
{
    bool doTranspose = flagTranspose();
    bool doInverse = flagInverse();
    uint j = gl_GlobalInvocationID.x;
    uint row = gl_WorkGroupID.y;

    if (PC.r == 2)
        fftIterationRadix2(j, row, PC.n, PC.ns, doTranspose, doInverse);
    else if (PC.r == 4)
        fftIterationRadix4(j, row, PC.n, PC.ns, doTranspose, doInverse);
}
