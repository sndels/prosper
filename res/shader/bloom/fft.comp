#pragma shader_stage(compute)

#extension GL_EXT_shader_image_load_formatted : require

#include "../common/math.glsl"
#include "../shared/shader_structs/push_constants/bloom/fft.h"

layout(set = 0, binding = 0) uniform image2D inOutData[2];

layout(push_constant) uniform PushConstants { FftPC PC; };

bool flagTranspose() { return bitfieldExtract(PC.flags, 0, 1) == 1; }
bool flagInverse() { return bitfieldExtract(PC.flags, 1, 1) == 1; }
bool flagNeedsRadix2() { return bitfieldExtract(PC.flags, 2, 1) == 1; }

vec4 loadData(image2D image, ivec2 p, bool doInverse)
{
    vec4 ret = imageLoad(image, p);
    if (doInverse)
        ret = ret.yxwz;
    return ret;
}

void storeData(image2D image, ivec2 p, vec4 c, bool doInverse)
{
    if (doInverse)
        c = c.yxwz;
    imageStore(image, p, c);
}

// Based on
// High Performance Discrete Fourier Transforms on Graphics Processors
// By Govindaraju et al.

uint expand(uint idxL, uint N1, uint N2)
{
    return (idxL / N1) * N1 * N2 + (idxL % N1);
}

vec4 mulI(vec4 c) { return vec4(-c.y, c.x, -c.w, c.z); }

vec4 mulComplex(vec4 a, vec4 b)
{
    return vec4(
        a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x, a.z * b.z - a.w * b.w,
        a.z * b.w + a.w * b.z);
}

void decimateRadix2(inout vec4 v[2])
{
    vec4 v0 = v[0];
    vec4 v1 = v[1];
    v[0] = v0 + v1;
    v[1] = v0 - v1;
}

void decimateRadix4(inout vec4 v[4])
{
    vec4 v0 = v[0];
    vec4 v1 = v[1];
    vec4 v2 = v[2];
    vec4 v3 = v[3];
    v[0] = v0 + v1 + v2 + v3;
    v[1] = v0 - mulI(v1) - v2 + mulI(v3);
    v[2] = v0 - v1 + v2 - v3;
    v[3] = v0 + mulI(v1) - v2 - mulI(v3);
}

void fftIterationRadix2Element(
    image2D inputImage, image2D outputImage, uint j, uint row, uint N, uint Ns,
    bool doTranspose, bool doInverse)
{
    const uint R = 2;
    vec4 v[R];

    uint idxS = j;
    float angle = -2. * PI * float(j % Ns) / float(Ns * R);
    for (uint r = 0; r < R; ++r)
    {
        ivec2 p = doTranspose ? ivec2(row, idxS + r * N / R)
                              : ivec2(idxS + r * N / R, row);
        // TODO:
        // Use some kind of LUT for the sines and cosines here, like ryg
        // suggests?
        vec4 c = loadData(inputImage, p, doInverse);
        vec2 twiddle = vec2(cos(r * angle), sin(r * angle));
        v[r] = mulComplex(c, twiddle.xyxy);
    }

    decimateRadix2(v);

    uint idxD = expand(j, Ns, R);
    for (uint r = 0; r < R; ++r)
    {
        ivec2 p =
            doTranspose ? ivec2(row, idxD + r * Ns) : ivec2(idxD + r * Ns, row);
        storeData(outputImage, p, v[r], doInverse);
    }
}

void fftIterationRadix2(
    image2D inputImage, image2D outputImage, uint localThreadIndex, uint row,
    uint N, uint Ns, bool doTranspose, bool doInverse)
{
    const uint R = 2;
    for (uint i = 0; i < N / R; i += GROUP_X)
    {
        fftIterationRadix2Element(
            inputImage, outputImage, i + localThreadIndex, row, N, Ns,
            doTranspose, doInverse);
    }
}

void fftIterationRadix4Element(
    image2D inputImage, image2D outputImage, uint j, uint row, uint N, uint Ns,
    bool doTranspose, bool doInverse)
{
    const uint R = 4;
    vec4 v[R];

    uint idxS = j;
    float angle = -2. * PI * float(j % Ns) / float(Ns * R);
    for (uint r = 0; r < R; ++r)
    {
        float col = idxS + r * N / R;
        ivec2 p = doTranspose ? ivec2(row, col) : ivec2(col, row);
        // TODO:
        // Use some kind of LUT for the sines and cosines here, like ryg
        // suggests?
        vec4 c = loadData(inputImage, p, doInverse);
        vec2 twiddle = vec2(cos(r * angle), sin(r * angle));
        v[r] = mulComplex(c, twiddle.xyxy);
    }

    decimateRadix4(v);

    uint idxD = expand(j, Ns, R);
    for (uint r = 0; r < R; ++r)
    {
        float col = idxD + r * Ns;
        ivec2 p = doTranspose ? ivec2(row, col) : ivec2(col, row);
        storeData(outputImage, p, v[r], doInverse);
    }
}

void fftIterationRadix4(
    image2D inputImage, image2D outputImage, uint localThreadIndex, uint row,
    uint N, uint Ns, bool doTranspose, bool doInverse)
{
    const uint R = 4;
    for (uint i = 0; i < N / R; i += GROUP_X)
    {
        fftIterationRadix4Element(
            inputImage, outputImage, i + localThreadIndex, row, N, Ns,
            doTranspose, doInverse);
    }
}

layout(local_size_x = GROUP_X) in;
void main()
{
    bool doTranspose = flagTranspose();
    bool doInverse = flagInverse();
    uint localThreadIndex = gl_LocalInvocationID.x;
    uint n = PC.n;
    uint row = gl_WorkGroupID.y;

    uint ns = 1;
    bool flipInOut = false;
    if (flagNeedsRadix2())
    {
        fftIterationRadix2(
            inOutData[0], inOutData[1], localThreadIndex, row, n, ns,
            doTranspose, doInverse);
        flipInOut = true;
        ns *= 2;
        groupMemoryBarrier();
        barrier();
    }

    while (ns < n)
    {
        if (flipInOut)
            fftIterationRadix4(
                inOutData[1], inOutData[0], localThreadIndex, row, n, ns,
                doTranspose, doInverse);
        else
            fftIterationRadix4(
                inOutData[0], inOutData[1], localThreadIndex, row, n, ns,
                doTranspose, doInverse);

        flipInOut = !flipInOut;
        ns *= 4;
        groupMemoryBarrier();
        barrier();
    }
}
