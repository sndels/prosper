#pragma shader_stage(compute)

#extension GL_EXT_shader_image_load_formatted : require

#include "../common/math.glsl"
#include "../shared/shader_structs/push_constants/bloom/fft.h"

layout(set = 0, binding = 0) uniform readonly image2D inDataReal;
layout(set = 0, binding = 1) uniform readonly image2D inDataImag;
layout(std430, set = 0, binding = 2) readonly buffer TwiddleLut
{
    vec2 twiddles[];
}
inTwiddleLut;
layout(set = 0, binding = 3) uniform writeonly image2D outDataReal;
layout(set = 0, binding = 4) uniform writeonly image2D outDataImag;

layout(push_constant) uniform PushConstants { FftPC PC; };

bool flagTranspose() { return bitfieldExtract(PC.flags, 0, 1) == 1; }

vec2 loadInput(ivec2 p)
{
    // TODO:
    // This check should only be needed for the first pass that samples from the
    // potentially smaller input texture
    if (any(greaterThanEqual(p, PC.inputResolution)))
        return vec2(0);

    vec2 c;
    c.x = imageLoad(inDataReal, p).x;
    c.y = imageLoad(inDataImag, p).x;
    return c;
}

void storeOutput(ivec2 p, vec2 c)
{
    imageStore(outDataReal, p, vec4(c.x, 0, 0, 0));
    imageStore(outDataImag, p, vec4(c.y, 0, 0, 0));
}

vec2 getTwiddle(uint jModNs, uint r, uint Ns, uint N, uint R)
{
    if (R == 2)
        // R == 2 is only used for the first iteration whose twiddle is trivial
        return vec2(1, 0);

    // TODO:
    // There are, what, 13 unique Ns?
    uint offset = 0;
    uint tmp = Ns;
    while (tmp > 1)
    {
        tmp /= 2;
        offset += tmp;
    }

    return inTwiddleLut.twiddles[(offset + jModNs) * 4 + r];
}

// Based on
// High Performance Discrete Fourier Transforms on Graphics Processors
// By Govindaraju et al.

uint expand(uint idxL, uint N1, uint N2)
{
    return (idxL / N1) * N1 * N2 + (idxL % N1);
}

vec2 mulI(vec2 c) { return vec2(-c.y, c.x); }

vec2 mulComplex(vec2 a, vec2 b)
{
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

void decimateRadix2(inout vec2 v[2])
{
    vec2 v0 = v[0];
    vec2 v1 = v[1];
    v[0] = v0 + v1;
    v[1] = v0 - v1;
}

void decimateRadix4(inout vec2 v[4])
{
    vec2 v0 = v[0];
    vec2 v1 = v[1];
    vec2 v2 = v[2];
    vec2 v3 = v[3];
    v[0] = v0 + v1 + v2 + v3;
    v[1] = v0 - mulI(v1) - v2 + mulI(v3);
    v[2] = v0 - v1 + v2 - v3;
    v[3] = v0 + mulI(v1) - v2 - mulI(v3);
}

shared vec2 sGroupTwiddles[GROUP_X * 4];

void loadSharedTwiddles(uint localThreadIndex, uint j, uint Ns, uint N, uint R)
{
    uint jModNs = Ns <= GROUP_X ? localThreadIndex % Ns : j % Ns;
    if (Ns > GROUP_X || jModNs == localThreadIndex)
    {
        sGroupTwiddles[localThreadIndex * 4] = getTwiddle(jModNs, 0, Ns, N, R);
        sGroupTwiddles[localThreadIndex * 4 + 1] =
            getTwiddle(jModNs, 1, Ns, N, R);
        if (R > 2)
        {
            sGroupTwiddles[localThreadIndex * 4 + 2] =
                getTwiddle(jModNs, 2, Ns, N, R);
            sGroupTwiddles[localThreadIndex * 4 + 3] =
                getTwiddle(jModNs, 3, Ns, N, R);
        }
    }
}

vec2 getSharedTwiddle(uint localThreadIndex, uint j, uint r, uint Ns)
{
    uint index = Ns <= GROUP_X ? j % Ns : localThreadIndex;
    return sGroupTwiddles[index * 4 + r];
}

void fftIterationRadix2(
    uint localThreadIndex, uint j, uint row, uint N, uint Ns, bool doTranspose)
{
    const uint R = 2;
    vec2 v[R];

    uint idxS = j;
    for (uint r = 0; r < R; ++r)
    {
        ivec2 p = doTranspose ? ivec2(row, idxS + r * N / R)
                              : ivec2(idxS + r * N / R, row);
        v[r] = loadInput(p);
    }

    loadSharedTwiddles(localThreadIndex, j, PC.ns, PC.n, PC.r);
    // Do all reads before this barrier to give the mem systems leeway to do
    // their thing
    barrier();

    for (uint r = 0; r < R; ++r)
    {
        vec2 twiddle = getSharedTwiddle(localThreadIndex, j, r, Ns);
        v[r] = mulComplex(v[r], twiddle);
    }

    decimateRadix2(v);

    uint idxD = expand(j, Ns, R);
    for (uint r = 0; r < R; ++r)
    {
        ivec2 p =
            doTranspose ? ivec2(row, idxD + r * Ns) : ivec2(idxD + r * Ns, row);
        storeOutput(p, v[r]);
    }
}

void fftIterationRadix4(
    uint localThreadIndex, uint j, uint row, uint N, uint Ns, bool doTranspose)
{
    const uint R = 4;
    vec2 v[R];

    uint idxS = j;
    for (uint r = 0; r < R; ++r)
    {
        ivec2 p = doTranspose ? ivec2(row, idxS + r * N / R)
                              : ivec2(idxS + r * N / R, row);
        v[r] = loadInput(p);
    }

    loadSharedTwiddles(localThreadIndex, j, PC.ns, PC.n, PC.r);
    // Do all reads before this barrier to give the mem systems leeway to do
    // their thing
    barrier();

    for (uint r = 0; r < R; ++r)
    {
        vec2 twiddle = getSharedTwiddle(localThreadIndex, j, r, Ns);
        v[r] = mulComplex(v[r], twiddle);
    }

    decimateRadix4(v);

    uint idxD = expand(j, Ns, R);
    for (uint r = 0; r < R; ++r)
    {
        float col = idxD + r * Ns;
        ivec2 p = doTranspose ? ivec2(row, col) : ivec2(col, row);
        storeOutput(p, v[r]);
    }
}

layout(local_size_x = GROUP_X) in;
void main()
{
    bool doTranspose = flagTranspose();
    uint localThreadIndex = gl_LocalInvocationID.x;
    uint j = gl_GlobalInvocationID.x;
    uint row = gl_WorkGroupID.y;

    if (PC.r == 2)
        fftIterationRadix2(localThreadIndex, j, row, PC.n, PC.ns, doTranspose);
    else if (PC.r == 4)
        fftIterationRadix4(localThreadIndex, j, row, PC.n, PC.ns, doTranspose);
}
