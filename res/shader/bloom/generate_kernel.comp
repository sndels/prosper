#pragma shader_stage(compute)

#include "../common/math.glsl"

layout(set = 0, binding = 0) uniform writeonly image2D outKernel;

float gaussian(float x, float a, float b, float c)
{
    return a * exp(-(x - b * b) / (2 * c * c));
}

layout(local_size_x = GROUP_X, local_size_y = GROUP_Y) in;
void main()
{
    ivec2 outRes = imageSize(outKernel);
    if (any(greaterThanEqual(gl_GlobalInvocationID.xy, outRes)))
        return;

    // Center the kernel in the image for easy tweaking. scale_kernel will
    // handle wrapping it across the corners for convolution.
    vec2 p = gl_GlobalInvocationID.xy / vec2(outRes);
    p = p * 2. - 1.;

    // Convolution will use R,B filters for G,A too. See prepare_kernel for
    // details.
    vec4 outValue = vec4(gaussian(length(p), .01, .175, .045));
    if (abs(p.y) < .005)
        outValue +=
            vec4(.01, .01, .5, .5) * gaussian(abs(p.x) * 10., .5, 1., 1.);

    imageStore(outKernel, ivec2(gl_GlobalInvocationID.xy), outValue);
}
