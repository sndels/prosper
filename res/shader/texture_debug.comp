
#pragma shader_stage(compute)

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_shader_image_load_formatted : require

#include "common/math.glsl"

layout(binding = 0) uniform texture2D inColor;
layout(binding = 1) uniform writeonly image2D outColor;
layout(binding = 2) uniform sampler inSampler;

layout(push_constant) uniform TextureDebugPC
{
    ivec2 inRes;
    ivec2 outRes;

    vec2 range;
    uint lod;
    uint flags;
}
PC;

uint flagChannelType() { return bitfieldExtract(PC.flags, 0, 3); }
bool flagAbsBeforeRange() { return bitfieldExtract(PC.flags, 3, 1) == 1; }
bool flagZoom() { return bitfieldExtract(PC.flags, 4, 1) == 1; }

layout(local_size_x = GROUP_X, local_size_y = GROUP_Y) in;
void main()
{
    ivec2 outCoord = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(outCoord, PC.outRes)))
        return;

    float inAspectRatio = float(PC.inRes.x) / float(PC.inRes.y);
    float outAspectRatio = float(PC.outRes.x) / float(PC.outRes.y);
    vec2 inUv = (vec2(outCoord) + .5) / vec2(PC.outRes);
    if (!any(equal(PC.inRes, PC.outRes)))
    {
        if (inAspectRatio > outAspectRatio)
        {
            // Scale limited by height
            int scaledHeight = int(PC.outRes.x / inAspectRatio);
            int bottomRow = int(PC.outRes.y - scaledHeight) / 2;
            inUv.y = float(outCoord.y - bottomRow) / float(scaledHeight);
        }
        else
        {
            // Scale limited by width
            int scaledWidth = int(PC.outRes.y * inAspectRatio);
            int leftColumn = (PC.outRes.x - scaledWidth) / 2;
            inUv.x = float(outCoord.x - leftColumn) / float(scaledWidth);
        }
    }

    if (flagZoom())
    {
        inUv *= PC.inRes;
        inUv = floor(inUv - .5) + .5;

        // Zoom in a quarter res windoe approximately at the center of the full
        // render view
        ivec2 center = PC.inRes / 2;
        ivec2 topLeft = center - PC.inRes / 8;
        inUv = topLeft + inUv / 4;

        inUv /= PC.inRes;
    }

    vec3 color = vec3(0);
    if (all(greaterThanEqual(inUv, vec2(0))) &&
        all(lessThanEqual(inUv, vec2(1))))
    {
        uint channel = flagChannelType();
        if (channel > 3)
            color =
                textureLod(sampler2D(inColor, inSampler), inUv, float(PC.lod))
                    .xyz;
        else
        {
            color = vec3(textureLod(
                sampler2D(inColor, inSampler), inUv, float(PC.lod))[channel]);
        }
    }

    if (flagAbsBeforeRange())
        color = abs(color);

    vec3 scaledColor = (color - PC.range.x) / (PC.range.y - PC.range.x);

    imageStore(outColor, outCoord, vec4(scaledColor, 1));
}
