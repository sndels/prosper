- Match bokeh size between post-process and RT
- Have separate resource debug name arrays for frames in flight?
  - Is there problem with having just one array that's cleared at the start of each frame?
- Document coverage for required features/limits from gpuinfo
- Use better compression scheme for normals
- Optimize cache generation
  - Make sure ISPC is using AVX
  - Make mip gen faster if its speed is an issue
  - When low-hanging fruits have been picked, parallelize cache generation
    - Still one transfer thread
    - Split cache generation out of texture ctor
    - Run cache gen wide on the remaining threads
- In asserted_cast do 
    else if (!std::is_same<T,V>) static_assert(!"No bounds check happen between these types");
  instead of just asserting !floatingpoint
- Span convenience ctor that takes in a single element
- Container.span() defaults to all elements
  - inference doesn't always work, could maybe be fixed on span ctor side as
    well if Span{container} is clearer than container.span()
- Reflect RT/AS layout and writes from shader
  - Requires some thought for how the pNext chain and non-uniform stage flags
    within a set are handled in a generic way
- CS group sizes as defines, make sure same value is used in shader and
  dispatch size calc
- IBL
  - Apply the reflection adjustment from the Frostbite siggraph14 course notes
  - A Multiple-Scattering Microfacet Model for Real-Time Image-based Lighting
- RayTracingPass
  - RtReference and RtDirectIllumination are 90% the same code
- All passes' shaders
  - Cull unused includes
  - Then, cull unused binding sets
- Better shadow/reflection offset
  - One of the Ray Tracing Gems had a solution
- Get rid of more includes in .hpps
  - ShaderReflection
    - unique_ptr? is the indirection expensive?
    - or store reflections per shader handle in device and query each time they are used?
      more expensive?
- Geometry optimization
  - meshoptimizer, mikktspace
  - cache resulting raw buffers on disc like with textures
    - hash raw bytes, if libs' outputs are stable? by input file touch time?
    - Separate file per mesh? could just read cache in loader thread like with
      textures
    - conversion wide, single thread that transfers data? messy handling for wide
      writes even though raw geometry writes dosn't have to use the transfer queue?
    - if wider, also go wide for texture compression
- Mesh shading
  - Async geometry loading/optimization first, add meshlet generation after
  - cone and per-tri culling?
    - https://zeux.io/2023/04/28/triangle-backface-culling/
    - Bench per-tri!
- Indirect draw
  - Per-mesh frustum culling by BB 
  - Depth sorting by BB
  - Meshlet draw indices and indirect args on GPU
- Split uint and float mesh buffers?
  - Bitcast op shows up in spirv, suggesting a potential perf hit
  - Could alias memory with two different bindings, but explicit separation sounds
    nicer
  - Should profile
- Have one BLAS per model instead of one BLAS per submodel
  - Reduces BLAS overlap in TLAS
  - Requires different mesh index logic
- Free managed resources that aren't used
  - Have a counter for each resource like for scratch buffers?
  - Make sure the frees don't cause things being reallocated repeatedly
    - Frees/reallocates should only happen when render passes are toggled
- Shader cache
  - Index by hash?
    - Will clutter the cache with useless blobs
    - Need to manually clean up when the cache gets too bloated
  - Index by main source path, compare hash?
    - Multiple versions of the same shader required?
    - Could get too messy and brittle
- Pipeline cache
  - https://zeux.io/2019/07/17/serializing-pipeline-cache/
- Calculate bitangent in pixel shader like suggested on the mikktspace site
- Fix init/load time crashes causing broken teardown and VMA asserts masking the
  actual root cause throws
  - Non-throwing ctors and separate init to make sure cleanup always happens?
- Have texture and mesh cache both next to the scene instead of textures being
  next to the textures?
- Remove explicit indices from enum classes that have concrete types
  - Error prone when adding/removing things, spec guarantees 0,1,2,3...
